// Package filecrypt implements filecrypt encryption and decryption protocol
//
// Filecrypt procotol is used to encrypt a set of different data structures
//  into a file
//
// A filecrypt object includes a  Digest Header, a Key Header, a encryption header, and a sequence of encrypted blocks.
//   There may be multiple filecrypt blocks with different encryption options. Typically, a filecrypt
//   block includes a data structure. Multiple filecrypt blocks can be appended toguether to encrypt
//   several data structures
//
//
// Digest Header includes a summary of the contents of the different FileCrypt blocks. Contents include:
//
//   version    [1 Byte]
//   SealType   [1 Byte]
//   nBlocks    [8 Bytes]
//   nonce      [16 Byte]
//
// Additionally, for every block :
//
//   offset [8 byte] : Offset in bytes of Encryption Header for this block
//   tag    [9 byte] : Tag to query the block during decryption. First byte includes tag size in bytes

// Key Header Format -> defined in fckeyhdr.go. It includes information to generate a key from a master
//   key
//  - Version       [1 Byte]
//  - Key Type      [1 Byte]
//  - Key contents  [Variable size] -> Filecrypt supports multiple key derivation protocols, including:
//       - No Key -> nokey.go
//       - Direct -> direct_key.go
//       - PBKDF2 -> pbkdf2dhr.go and and pbkdf2.go
//
//  There is only a single key header per file. All blocks use same key derivation mechanisms
//
//  Encryption Header Format -> defined in hre.go. It includes information to encrypt data. Header
//   it not encrypted. Header is 16 bytes long
//   - Version       [1 Byte]
//   - FC type       [1 byte] Indicates how data blocks are encrypted. Methods supported so far:
//         GCM-128, GCM-256 : defined in gcm.go
//         RSA
//         No encryption    : clear.go
//   - Blocksize     [1 byte] Encryption block size (identifier). Currently FC_BSIZE_BYTES_128 and _256 bit supported
//                   for GCM, and FC_BIZE_BYTES_2048 and _4096 for RSA
//   - Noncesize     [1 byte] Size in bytes of nonce (if needed)
//   - Last_blocksize[1 byte] Size in bytes of last cleartext block
//   - nblocks       [8 byte] Number of bytes of cyphertext generated by encryption mechanism
//
//   Every filecrypt block includes a Encryption Header block. It can vary between different filecrypt
//    blocks.
//
//   After the encryption header there are N blocks of encrypted cyphertext

package filecrypt

import (
	"bytes"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/binary"
	"fmt"
	"os"
)

// Interface to describe FileCryptKey operations:
type fileCryptKey interface {
	generateKey(fname string) ([]byte, error)
	retrieveKey(key, d []byte, h *[]byte, f *os.File) ([]byte, error)
	toBytes() ([]byte, error)
	fromBytes([]byte)
	fillHdr(KeyIn []byte, Params ...int) error
}

// Interface to describe FileCryptEnc operations:
//   Encrypt : Encrypt cleartext into a filecrypt compatible format file
//   Decrypt : Decrypt a filecrypt file to cleartext
type fileCryptEnc interface {
	decrypt(cyphertext, key []byte) (interface{}, error)
	encrypt(fname string, key []byte, cleartext interface{}) error
	toBytes() ([]byte, error)
	fromBytes([]byte)
	setNBlocks(nbytes int64)
	getNBlockBytes() int64
	getNoncePaddingLen() int
	setNonceSize(s int)
	fillHdr(Version, Fctype, Blocksize int) error
}

// Hash Functions
const (
	FC_NOHASH = iota
	FC_HASH_SHA256
	FC_NHASH
)

// Offset and Sizes
const (
	FC_HDR_REG_VERSION_SIZE = 1
	FC_HDR_REG_SEALT_SIZE   = 1
	FC_HDR_REG_NBLOCKS_SIZE = 8
	FC_HDR_REG_NONCE_SIZE   = FC_SEAL_SALTLEN
	FC_HDR_REG_BOFFSET_SIZE = 8
	FC_HDR_REG_BTAG_SIZE    = 9

	FC_HDR_REG_VERSION_OFFSET = 0
	FC_HDR_REG_SEALT_OFFSET   = FC_HDR_REG_VERSION_SIZE
	FC_HDR_REG_NBLOCKS_OFFSET = FC_HDR_REG_SEALT_OFFSET + FC_HDR_REG_SEALT_SIZE
	FC_HDR_REG_NONCE_OFFSET   = FC_HDR_REG_NBLOCKS_OFFSET + FC_HDR_REG_NBLOCKS_SIZE
	FC_HDR_REG_BDATA_OFFSET   = FC_HDR_REG_NONCE_OFFSET + FC_HDR_REG_NONCE_SIZE
	FC_HDR_REG_BOFFSET_OFFSET = 0
	FC_HDR_REG_BTAG_OFFSET    = FC_HDR_REG_BOFFSET_SIZE
	FC_HDR_REG_END_OFFSET     = FC_HDR_REG_BTAG_OFFSET + FC_HDR_REG_BTAG_SIZE
)

const (
	MODE_INIT = iota
	MODE_MODIFY
)

// Version (Backwards interop)
const (
	FC_HDR_VERSION_1 = iota
	FC_HDR_NVERSION
)

const (
	FC_HDR_DEF_VERSION = FC_HDR_VERSION_1
)

const (
	FC_SEAL_SALTLEN = 16
	FC_SEAL_NITER   = 80000
	FC_SEAL_KLEN    = FC_BSIZE_BYTES_256
	FC_SEAL_LEN     = FC_BSIZE_BYTES_256
)

type blockCrypt struct {
	offset int64                      // in hdr
	tag    [FC_HDR_REG_BTAG_SIZE]byte // in hdr
}

type FileCrypt struct {
	version      int   // in hdr
	sealType     int   // in hdr
	nBlocks      int64 // in hdr
	nonce        []byte
	filledBlocks int64
	fname        string
	keyOut       []byte
	blocks       []blockCrypt
	msg          []byte
	hmacKey      []byte
	hdrK         []byte
}

// Constructor
//   params are optional parameters for the key header. If not supplied, the following default params are assigned:
//      fcKTpye =  FC_KEY_T_NOKEY / FC__KEY_T_DIRECT  => No additional parameter required
//      fcKType =  FC_KEY_T_PBKDF2     => hashType : FC_HASH_SHA256, Niter : 60000
//                                        keyLen   : 256 B, Salt Len : 12 Bytes
func New(nBlocks int, fname string, hmacKey, fcKey []byte, fcKType int, params ...int) (*FileCrypt, error) {
	fileCrypt := FileCrypt{
		version:  FC_HDR_DEF_VERSION,
		fname:    fname,
		nBlocks:  int64(nBlocks),
		sealType: FC_KEY_T_PBKDF2,
	}
	fileCrypt.nonce = make([]byte, FC_SEAL_SALTLEN)
	fileCrypt.hmacKey = make([]byte, len(hmacKey))
	copy(fileCrypt.hmacKey, hmacKey)

	fileCrypt.blocks = make([]blockCrypt, nBlocks)

	paramsK := make([]int, 0)
	paramsK = append(paramsK, FC_HDRK_DEF_VERSION)
	paramsK = append(paramsK, fcKType)
	paramsK = append(paramsK, params...)

	// Create Key Header
	hdrK, err := NewHdrKey(fcKey, paramsK...)
	if err != nil {
		return nil, fmt.Errorf("NewHdrKey : %w", err)
	}

	// Add Registry
	_, err = fileCrypt.write(MODE_INIT)
	if err != nil {
		return nil, fmt.Errorf("write : %w", err)
	}
	// Add HdrK
	fileCrypt.keyOut, err = hdrK.generateKey(fname)
	if err != nil {
		return nil, fmt.Errorf("GenerateKey : %w", err)
	}
	// Keep hdrk
	fileCrypt.hdrK, err = hdrK.toBytes()

	return &fileCrypt, nil
}

// Constructor from Bytes
func NewFromBytes(reg []byte) *FileCrypt {
	fc := FileCrypt{}

	fc.version = int(reg[FC_HDR_REG_VERSION_OFFSET])
	fc.sealType = int(reg[FC_HDR_REG_SEALT_OFFSET])
	fc.nBlocks = int64(binary.LittleEndian.Uint64(reg[FC_HDR_REG_NBLOCKS_OFFSET:FC_HDR_REG_NONCE_OFFSET]))
	fc.nonce = reg[FC_HDR_REG_NONCE_OFFSET:FC_HDR_REG_BDATA_OFFSET]

	fc.blocks = make([]blockCrypt, fc.nBlocks)

	offset := FC_HDR_REG_BDATA_OFFSET
	for idx := int64(0); idx < fc.nBlocks; idx += 1 {
		fc.blocks[idx].offset = int64(binary.LittleEndian.Uint64(reg[offset : offset+FC_HDR_REG_BOFFSET_SIZE]))
		offset += FC_HDR_REG_BOFFSET_SIZE
		copy(fc.blocks[idx].tag[:], reg[offset:offset+FC_HDR_REG_BTAG_SIZE])
		offset += FC_HDR_REG_BTAG_SIZE
	}

	return &fc
}

// Constructor from File
func NewFromFile(hmacKey []byte, fname string) (*FileCrypt, error) {
	// open file for reading
	file, err := openFileR(fname)
	defer file.Close()
	if err != nil {
		return nil, fmt.Errorf("Open file : %w", err)
	}
	buf, err := readNBytesFromFile(file, FC_HDR_REG_BDATA_OFFSET)
	if err != nil {
		return nil, fmt.Errorf("readNBytesFromFile : %w", err)
	}
	nBlocks := int64(binary.LittleEndian.Uint64(buf[FC_HDR_REG_NBLOCKS_OFFSET:FC_HDR_REG_NONCE_OFFSET]))
	fcLen := blockLen(nBlocks)

	buf2, err := readNBytesFromFile(file, int(fcLen))
	if err != nil {
		return nil, fmt.Errorf("readNBytesFromFile : %w", err)
	}
	buf = append(buf, buf2...)
	fileCrypt := NewFromBytes(buf)

	fileCrypt.fname = fname
	fileCrypt.hmacKey = make([]byte, len(hmacKey))
	copy(fileCrypt.hmacKey, hmacKey)

	return fileCrypt, nil
}

// List available tags
func (fc FileCrypt) ListTags() [][]byte {
	var newTag [][]byte
	for _, el := range fc.blocks {
		lenEl := el.tag[0]
		tag := make([]byte, lenEl)
		copy(tag, el.tag[1:lenEl+1])
		newTag = append(newTag, tag)
	}
	return newTag
}

// Returns number of FileCrypt blocks
func (fc FileCrypt) NBlocks() int {
	return int(fc.nBlocks)
}

// Returns nonce used to derive hmac key
func (fc *FileCrypt) Nonce() []byte {
	return fc.nonce
}

// Add block to Filecrypt object. It will encrypt it according the specified headers
func (fc *FileCrypt) AddBlock(tag []byte, encType int, cleartext interface{}) error {
	var blockSize int
	if encType == FC_GCM || encType == FC_CLEAR {
		blockSize = FC_BSIZE_BYTES_256
	} else if encType == FC_RSA {
		blockSize = FC_BSIZE_BYTES_2048
	} else {
		return fmt.Errorf("Unknown encryption type")
	}

	hdrE, err := NewHdrEncrypt(FC_HDRE_DEF_VERSION, encType, blockSize)
	if err != nil {
		return fmt.Errorf("NewHdrEncrypt : %w", err)
	}
	blockIdx := fc.filledBlocks

	// Copy Tag
	err = fc.copyTag(blockIdx, tag)
	if err != nil {
		return fmt.Errorf("copyTag : %w", err)
	}

	// Add offset
	fc.updateOffset(blockIdx)

	// Encrypt block
	err = hdrE.encrypt(fc.fname, fc.keyOut, cleartext)
	if err != nil {
		return fmt.Errorf("Encrypt : %w", err)
	}

	fc.filledBlocks += 1

	// Update fc header
	if fc.filledBlocks == fc.nBlocks {
		fc.setNonce()
		fc.write(MODE_MODIFY)

		hmac, err := fc.seal()
		if err != nil {
			return fmt.Errorf("Seal : %w", err)
		}
		file, _ := os.OpenFile(fc.fname, os.O_RDWR, 0644)
		if err != nil {
			return fmt.Errorf("Open file : %w", err)
		}
		file.Seek(int64(0), 2)
		file.Write(hmac)
	}

	return nil
}

// Filecrypt decryption routine. Takes some cyphertext file and based on the type of decryption
//  specified in the header applies the desired decryption algorithm.
func (fc FileCrypt) DecryptAll(keyIn []byte) ([]interface{}, error) {
	// open file for reading
	file, err := openFileR(fc.fname)
	defer file.Close()
	if err != nil {
		return nil, fmt.Errorf("Open file : %w", err)
	}

	var result []interface{}
	fcLen := blockLen(fc.nBlocks) + FC_HDR_REG_BDATA_OFFSET

	// Get Encryption Key
	fc.keyOut, err = retrieveKey(file, int64(fcLen), keyIn, &fc.hdrK)
	if err != nil {
		return nil, fmt.Errorf("retrieveKey : %w", err)
	}
	if !fc.CheckSeal() {
		return nil, fmt.Errorf("HMAC doesn't match")
	}

	for blockIdx := int64(0); blockIdx < fc.nBlocks; blockIdx += 1 {
		blockPosition := fc.blocks[blockIdx].offset
		// Decrypt block
		p, err := decryptBlock(file, int64(blockPosition), fc.keyOut)
		if err == nil {
			result = append(result, p)
		}

	}
	return result, nil
}

// Filecrypt decryption routine. Takes some cyphertext file and based on the type of decryption
//  specified in the header applies the desired decryption algorithm. Tag is used to decrypt block identified
// by such tag
func (fc FileCrypt) DecryptSingle(tag []byte, keyIn []byte) (interface{}, error) {

	blockIdx, err := fc.findTag(tag)
	if err != nil {
		return nil, fmt.Errorf("Exceeded number of blocks")
	}
	// open file for reading
	file, err := openFileR(fc.fname)
	defer file.Close()
	if err != nil {
		return nil, fmt.Errorf("Open file : %w", err)
	}

	fcLen := blockLen(fc.nBlocks) + FC_HDR_REG_BDATA_OFFSET

	// Get Encryption Key If necessary
	if fc.keyOut == nil {
		fc.keyOut, err = retrieveKey(file, int64(fcLen), keyIn, &fc.hdrK)
		if err != nil {
			return nil, fmt.Errorf("retrieveKey : %w", err)
		}
		if !fc.CheckSeal() {
			return nil, fmt.Errorf("HMAC doesn't match")
		}
	}

	blockPosition := fc.blocks[blockIdx].offset
	// Decrypt block
	return decryptBlock(file, int64(blockPosition), fc.keyOut)

}

// Returns hmac code in FileCrypt object
func (fc FileCrypt) HMACRead() ([]byte, error) {
	// open file for reading
	file, err := openFileR(fc.fname)
	defer file.Close()
	if err != nil {
		return nil, fmt.Errorf("Open file : %w", err)
	}
	file.Seek(int64(-FC_SEAL_LEN), 2)
	return readNBytesFromFile(file, FC_SEAL_LEN)
}

// Checks if hmac computed is equal to hmac in FileCrypt object
func (fc *FileCrypt) CheckSeal() bool {
	hmac1, err := fc.seal()
	if err != nil {
		return false
	}
	hmac2, err := fc.HMACRead()
	if err != nil {
		return false
	}
	if !bytes.Equal(hmac1, hmac2) {
		return false
	}
	return true
}

func (fc *FileCrypt) setNonce() error {
	var err error
	fc.nonce, err = genRandomBytes(FC_SEAL_SALTLEN)
	return err
}

func blockLen(nBlocks int64) int64 {
	return nBlocks * FC_HDR_REG_END_OFFSET
}

// Write FC header to file
func (fc FileCrypt) write(mode int) (int, error) {
	hdr := fc.toBytes()
	if mode == MODE_INIT {
		file, err := openFileW(fc.fname)
		defer file.Close()
		if err != nil {
			return 0, fmt.Errorf("Open file : %w", err)
		}
		// write header to file
		wb, err := file.Write(hdr)
		if err != nil {
			return 0, fmt.Errorf("Write file : %w", err)
		}
		return wb, nil

	} else {
		file, err := os.OpenFile(fc.fname, os.O_RDWR, 0644)
		defer file.Close()
		if err != nil {
			return 0, fmt.Errorf("Open file : %w", err)
		}
		wb, err := file.WriteAt(hdr, 0)
		if err != nil {
			return 0, fmt.Errorf("Write file : %w", err)
		}
		return wb, nil
	}

}

// Serialize
func (fc FileCrypt) toBytes() []byte {
	b := make([]byte, 0)

	b = append(b, byte(fc.version))
	b = append(b, byte(fc.sealType))

	nBlocksB := make([]byte, FC_HDR_REG_NBLOCKS_SIZE)
	binary.LittleEndian.PutUint64(nBlocksB, uint64(fc.nBlocks))
	b = append(b, nBlocksB...)
	b = append(b, fc.nonce...)

	for idx := int64(0); idx < fc.nBlocks; idx += 1 {
		blockOffsetB := make([]byte, FC_HDR_REG_BOFFSET_SIZE)
		binary.LittleEndian.PutUint64(blockOffsetB, uint64(fc.blocks[idx].offset))
		b = append(b, blockOffsetB...)
		b = append(b, fc.blocks[idx].tag[:]...)
	}

	return b
}

func (fc *FileCrypt) updateOffset(idx int64) error {
	if idx > fc.nBlocks {
		return fmt.Errorf("updateOffset : Exceeded number of blocks")
	}

	f, err := os.Stat(fc.fname)
	if err != nil {
		return fmt.Errorf("Stat file : %w", err)
	}
	fc.blocks[idx].offset = f.Size()

	return nil
}

func (fc *FileCrypt) copyTag(blockIdx int64, fromTag []byte) error {
	if blockIdx > fc.nBlocks {
		return fmt.Errorf("Exceeded number of blocks")
	}
	copy(fc.blocks[blockIdx].tag[1:], fromTag)
	lenTag := len(fromTag)
	fc.blocks[blockIdx].tag[0] = FC_HDR_REG_BTAG_SIZE - 1
	if lenTag <= FC_HDR_REG_BTAG_SIZE-1 {
		fc.blocks[blockIdx].tag[0] = byte(len(fromTag))
	}

	return nil
}

func (fc FileCrypt) findTag(tag []byte) (int, error) {
	myTags := fc.ListTags()
	for idx, myTag := range myTags {
		if bytes.Equal(myTag, tag) {
			return idx, nil
		}
	}
	return -1, fmt.Errorf("Tag not found")
}

func (fc *FileCrypt) seal() ([]byte, error) {

	fc.msg = append(fc.msg, fc.toBytes()...)
	fc.msg = append(fc.msg, fc.hdrK...)

	file, _ := os.OpenFile(fc.fname, os.O_RDWR, 0644)
	defer file.Close()
	for blockIdx := int64(0); blockIdx < fc.nBlocks; blockIdx += 1 {
		blockPosition := fc.blocks[blockIdx].offset
		// Set correct position
		_, err := file.Seek(int64(blockPosition), 0)
		if err != nil {
			return nil, fmt.Errorf("Seek file : %w", err)
		}
		// initialize Encryption Hdr
		hdrE, err := newHdrEncryptFromFile(file)
		if err != nil {
			return nil, fmt.Errorf("newHdrEncryptFromFile : %w", err)
		}
		hdrB, err := hdrE.toBytes()
		fc.msg = append(fc.msg, hdrB...)

		if hdrB[FC_HDR_FCTYPE_OFFSET] == FC_RSA || hdrB[FC_HDR_FCTYPE_OFFSET] == FC_CLEAR {
			// read Blocks (with nonce). If error during reading blocks abort
			blockBytes := hdrE.getNBlockBytes()
			blockBuffer, err := readNBytesFromFile(file, int(blockBytes))
			if err != nil {
				return nil, fmt.Errorf("readNBytesFromFile : %w", err)
			}
			fc.msg = append(fc.msg, blockBuffer...)
		}
	}

	p := Pbkdf2Fc{
		keyIn:    fc.hmacKey,
		salt:     fc.nonce,
		iter:     FC_SEAL_NITER,
		outlen:   FC_SEAL_KLEN,
		hashtype: FC_HASH_SHA256,
	}
	p.computeKey()
	hash := hmac.New(sha256.New, p.keyOut)
	hash.Write(fc.msg)
	hmac := hash.Sum(nil)

	return hmac, nil
}
